C51 COMPILER V9.54   MAIN                                                                  11/02/2025 10:55:04 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2           * STC89C516 任务完成率显示器
   3           * 功能：
   4           * 1. 通过动态数码管显示任务完成进度百分比
   5           * 2. 通过蜂鸣器播放提示音（模拟end.mp3效果）
   6           * 3. 通过串口接收来自电脑的任务完成率数据
   7           */
   8          
   9          #include <intrins.h> 
  10          #include <REGX52.H>
  11          
  12          // 引脚定义
  13          #define DIG_PORT P0    // 数码管段选接在P0口
  14          #define WEI_PORT P1    // 数码管位选接在P1口
  15          #define BUZZER_PORT P3 // 蜂鸣器接在P3口
  16          #define BUZZER_BIT 7   // 蜂鸣器接在P3的第7位
  17          
  18          // 使用位操作控制蜂鸣器
  19          #define BUZZER_ON BUZZER_PORT &= ~(1 << BUZZER_BIT)
  20          #define BUZZER_OFF BUZZER_PORT |= (1 << BUZZER_BIT)
  21          #define BUZZER_TOGGLE BUZZER_PORT ^= (1 << BUZZER_BIT)
  22          
  23          // 位掩码定义
  24          #define WEI1_MASK 0x01
  25          #define WEI2_MASK 0x02
  26          #define WEI3_MASK 0x04
  27          #define WEI4_MASK 0x08
  28          
  29          // 百分号段码（共阴极）
  30          #define PERCENT_SIGN 0x63
  31          
  32          // 全局变量
  33          unsigned char completion_rate = 0;   // 完成率（0-100）
  34          unsigned char receive_buffer[20];    // 串口接收缓冲区
  35          unsigned char receive_index = 0;     // 接收缓冲区索引
  36          unsigned char receive_complete = 0;  // 接收完成标志
  37          unsigned char current_display_pos = 0; // 当前显示的数码管位置
  38          unsigned char play_sound_flag = 0;   // 播放提示音标志
  39          
  40          unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
  41          
  42          //数码管显示子函数
  43          void display_digit(unsigned char Location,Number)
  44          {
  45   1        switch(Location)    //位码输出
  46   1        {
  47   2          case 1:P2_4=1;P2_3=1;P2_2=  1;break;
  48   2          case 2:P2_4=1;P2_3=1;P2_2=0;break;
  49   2          case 3:P2_4=1;P2_3=0;P2_2=1;break;
  50   2          case 4:P2_4=1;P2_3=0;P2_2=0;break;
  51   2          case 5:P2_4=0;P2_3=1;P2_2=1;break;
  52   2          case 6:P2_4=0;P2_3=1;P2_2=0;break;
  53   2          case 7:P2_4=0;P2_3=0;P2_2=1;break;
  54   2          case 8:P2_4=0;P2_3=0;P2_2=0;break;
C51 COMPILER V9.54   MAIN                                                                  11/02/2025 10:55:04 PAGE 2   

  55   2        }
  56   1            
  57   1      
  58   1      void init_serial();
*** ERROR C141 IN LINE 58 OF main.c: syntax error near 'void'
  59   1      void init_timer();
  60   1      void display_digit(unsigned char position, unsigned char digit);
  61   1      void parse_data();
  62   1      void delay(unsigned int ms);
  63   1      void play_buzzer_sound();
  64   1      
  65   1      // 主函数
  66   1      void main() {
  67   2          // 初始化
  68   2          init_serial();
  69   2          init_timer();
  70   2          
  71   2          // 设置引脚为输出模式
  72   2          DIG_PORT = 0x00;  // 初始状态数码管熄灭（共阴极）
  73   2          WEI_PORT = 0xff;  // 初始状态数码管位选关闭
  74   2          BUZZER_OFF;       // 初始状态蜂鸣器关闭
  75   2      
  76   2          // 主循环
  77   2          while (1) {
  78   3              // 如果接收到完整数据
  79   3              if (receive_complete) {
  80   4                  parse_data();           // 解析接收到的数据
  81   4                  receive_complete = 0;   // 重置接收完成标志
  82   4                  receive_index = 0;      // 重置接收索引
  83   4              }
  84   3              
  85   3              // 如果需要播放提示音
  86   3              if (play_sound_flag) {
  87   4                  play_buzzer_sound();
  88   4                  play_sound_flag = 0;
  89   4              }
  90   3          }
  91   2      }
  92   1      
  93   1      // 初始化串口通信
  94   1      void init_serial() {
  95   2          SCON = 0x50;  // 串口工作在模式1，允许接收
  96   2          TMOD = 0x20;  // 定时器1工作在模式2（自动重装）
  97   2          TH1 = 0xfd;   // 波特率9600（晶振11.0592MHz）
  98   2          TL1 = 0xfd;
  99   2          TR1 = 1;      // 启动定时器1
 100   2          ES = 1;       // 允许串口中断
 101   2          EA = 1;       // 允许总中断
 102   2      }
 103   1      
 104   1      // 初始化定时器0用于数码管动态扫描
 105   1      void init_timer() {
 106   2          TMOD |= 0x01;  // 定时器0工作在模式1
 107   2          TH0 = (65536 - 5000) / 256;  // 定时5ms（更快的扫描频率）
 108   2          TL0 = (65536 - 5000) % 256;
 109   2          ET0 = 1;       // 允许定时器0中断
 110   2          TR0 = 1;       // 启动定时器0
 111   2      }
 112   1      
 113   1      // 解析接收到的数据
 114   1      void parse_data() {
 115   2          unsigned char i;
C51 COMPILER V9.54   MAIN                                                                  11/02/2025 10:55:04 PAGE 3   

 116   2          
 117   2          // 查找指令类型
 118   2          for (i = 0; i < receive_index; i++) {
 119   3              // 完成率指令：P后跟百分率值（0-100）
 120   3              if (receive_buffer[i] == 'P' && i + 1 < receive_index) {
 121   4                  completion_rate = receive_buffer[i + 1];
 122   4                  // 确保完成率在有效范围内
 123   4                  if (completion_rate > 100) {
 124   5                      completion_rate = 100;
 125   5                  }
 126   4                  // 发送确认信号
 127   4                  SBUF = 'P';
 128   4                  while (!TI);
 129   4                  TI = 0;
 130   4                  break;
 131   4              }
 132   3              // 播放声音指令：S
 133   3              if (receive_buffer[i] == 'S') {
 134   4                  play_sound_flag = 1;
 135   4                  // 发送确认信号
 136   4                  SBUF = 'S';
 137   4                  while (!TI);
 138   4                  TI = 0;
 139   4                  break;
 140   4              }
 141   3          }
 142   2      }
 143   1      
 144   1      // 延时函数
 145   1      void delay(unsigned int ms) {
 146   1          unsigned int i, j;
 147   1          for (i = 0; i < ms; i++) {
 148   2              for (j = 0; j < 120; j++);  // 大约1ms的延时（晶振11.0592MHz）
 149   2          }
 150   1      }
 151          
 152          // 蜂鸣器播放提示音（模拟end.mp3效果）
 153          void play_buzzer_sound() {
 154   1          unsigned int i, j;
 155   1          
 156   1          // 播放一段简单的旋律
 157   1          for (i = 0; i < 3; i++) {
 158   2              // 高音
 159   2              for (j = 0; j < 200; j++) {
 160   3                  BUZZER_TOGGLE;
 161   3                  delay(1);
 162   3              }
 163   2              
 164   2              // 低音
 165   2              for (j = 0; j < 200; j++) {
 166   3                  BUZZER_TOGGLE;
 167   3                  delay(2);
 168   3              }
 169   2          }
 170   1          
 171   1          BUZZER_OFF;  // 关闭蜂鸣器
 172   1      }
 173          
 174          // 串口中断服务函数
 175          void serial_isr() interrupt 4 {
 176   1          if (RI) {
 177   2              RI = 0;  // 清除接收中断标志
C51 COMPILER V9.54   MAIN                                                                  11/02/2025 10:55:04 PAGE 4   

 178   2              
 179   2              // 读取接收到的数据
 180   2              receive_buffer[receive_index] = SBUF;
 181   2              
 182   2              // 检查是否接收到换行符，表示数据帧结束
 183   2              if (receive_buffer[receive_index] == '\n' || receive_index >= 19) {
 184   3                  receive_complete = 1;
 185   3              } else {
 186   3                  receive_index++;
 187   3              }
 188   2          }
 189   1          
 190   1          if (TI) {
 191   2              TI = 0;  // 清除发送中断标志
 192   2          }
 193   1      }
 194          
 195          // 定时器0中断服务函数（用于数码管动态扫描）
 196          void timer0_isr() interrupt 1 {
 197   1          unsigned char hundreds, tens, units;
 198   1          
 199   1          TH0 = (65536 - 5000) / 256;  // 重新加载初值
 200   1          TL0 = (65536 - 5000) % 256;
 201   1          
 202   1          // 循环显示不同的位置
 203   1          current_display_pos++;
 204   1          if (current_display_pos > 4) {
 205   2              current_display_pos = 1;
 206   2          }
 207   1          
 208   1          // 分解完成率为百位、十位和个位
 209   1          hundreds = completion_rate / 100;
 210   1          tens = (completion_rate % 100) / 10;
 211   1          units = completion_rate % 10;
 212   1          
 213   1          // 根据当前位置显示相应的数字
 214   1          switch (current_display_pos) {
 215   2              case 1:
 216   2                  if (hundreds > 0) {
 217   3                      display_digit(1, hundreds);  // 显示百位
 218   3                  } else {
 219   3                      // 不显示前导零，直接关闭显示
 220   3                      WEI_PORT = 0xff;
 221   3                      DIG_PORT = 0x00;
 222   3                  }
 223   2                  break;
 224   2              case 2:
 225   2                  if (hundreds > 0 || tens > 0) {
 226   3                      display_digit(2, tens);  // 显示十位
 227   3                  } else {
 228   3                      // 不显示前导零，直接关闭显示
 229   3                      WEI_PORT = 0xff;
 230   3                      DIG_PORT = 0x00;
 231   3                  }
 232   2                  break;
 233   2              case 3:
 234   2                  display_digit(3, units);  // 显示个位
 235   2                  break;
 236   2              case 4:
 237   2                  display_digit(4, 10);  // 显示百分号
 238   2                  break;
 239   2          }
C51 COMPILER V9.54   MAIN                                                                  11/02/2025 10:55:04 PAGE 5   

 240   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  1 ERROR(S)
